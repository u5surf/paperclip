<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `unify` mod in crate `ena`."><meta name="keywords" content="rust, rustlang, rust-lang, unify"><title>ena::unify - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../ena/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a><p class='location'>Module unify</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'><a href='../index.html'>ena</a></p><script>window.sidebarCurrent = {name: 'unify', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/ena/unify/mod.rs.html#11-537' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>ena</a>::<wbr><a class="mod" href=''>unify</a></span></h1><div class='docblock'><p>Union-find implementation. The main type is <code>UnificationTable</code>.</p>
<p>You can define your own type for the <em>keys</em> in the table, but you
must implement <code>UnifyKey</code> for that type. The assumption is that
keys will be newtyped integers, hence we require that they
implement <code>Copy</code>.</p>
<p>Keys can have values associated with them. The assumption is that
these values are cheaply cloneable (ideally, <code>Copy</code>), and some of
the interfaces are oriented around that assumption. If you just
want the classical &quot;union-find&quot; algorithm where you group things
into sets, use the <code>Value</code> type of <code>()</code>.</p>
<p>When you have keys with non-trivial values, you must also define
how those values can be merged. As part of doing this, you can
define the &quot;error&quot; type to return on error; if errors are not
possible, use <code>NoError</code> (an uninstantiable struct). Using this
type also unlocks various more ergonomic methods (e.g., <code>union()</code>
in place of <code>unify_var_var()</code>).</p>
<p>The best way to see how it is used is to read the <code>tests.rs</code> file;
search for e.g. <code>UnitKey</code>.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.InPlace.html" title='ena::unify::InPlace struct'>InPlace</a></td><td class='docblock-short'><p>Backing store for an in-place unification table.
Not typically used directly.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.NoError.html" title='ena::unify::NoError struct'>NoError</a></td><td class='docblock-short'><p>A struct which can never be instantiated. Used
for the error type for infallible cases.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Snapshot.html" title='ena::unify::Snapshot struct'>Snapshot</a></td><td class='docblock-short'><p>At any time, users may snapshot a unification table.  The changes
made during the snapshot may either be <em>committed</em> or <em>rolled back</em>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.UnificationTable.html" title='ena::unify::UnificationTable struct'>UnificationTable</a></td><td class='docblock-short'><p>Table of unification keys and their values. You must define a key type K
that implements the <code>UnifyKey</code> trait. Unification tables can be used in two-modes:</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.VarValue.html" title='ena::unify::VarValue struct'>VarValue</a></td><td class='docblock-short'><p>Value of a unification key. We implement Tarjan's union-find
algorithm: when two keys are unified, one of them is converted
into a &quot;redirect&quot; pointing at the other. These redirects form a
DAG: the roots of the DAG (nodes that are not redirected) are each
associated with a value of type <code>V</code> and a rank. The rank is used
to keep the DAG relatively balanced, which helps keep the running
time of the algorithm under control. For more information, see
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">http://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.EqUnifyValue.html" title='ena::unify::EqUnifyValue trait'>EqUnifyValue</a></td><td class='docblock-short'><p>A convenient helper for unification values which must be equal or
else an error occurs. For example, if you are unifying types in a
simple functional language, this may be appropriate, since (e.g.)
you can't unify a type variable bound to <code>int</code> with one bound to
<code>float</code> (but you can unify two type variables both bound to
<code>int</code>).</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.UnificationStore.html" title='ena::unify::UnificationStore trait'>UnificationStore</a></td><td class='docblock-short'><p>Largely internal trait implemented by the unification table
backing store types. The most common such type is <code>InPlace</code>,
which indicates a standard, mutable unification table.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.UnifyKey.html" title='ena::unify::UnifyKey trait'>UnifyKey</a></td><td class='docblock-short'><p>This trait is implemented by any type that can serve as a type
variable. We call such variables <em>unification keys</em>. For example,
this trait is implemented by <code>IntVid</code>, which represents integral
variables.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.UnifyValue.html" title='ena::unify::UnifyValue trait'>UnifyValue</a></td><td class='docblock-short'><p>Trait implemented for <strong>values</strong> associated with a unification
key. This trait defines how to merge the values from two keys that
are unioned together. This merging can be fallible. If you attempt
to union two keys whose values cannot be merged, then the error is
propagated up and the two keys are not unioned.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.InPlaceUnificationTable.html" title='ena::unify::InPlaceUnificationTable type'>InPlaceUnificationTable</a></td><td class='docblock-short'><p>A unification table that uses an &quot;in-place&quot; vector.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "ena";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>